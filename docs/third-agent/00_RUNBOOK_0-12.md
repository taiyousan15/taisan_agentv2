# 第三エージェント統合ランブック（0〜12 完全版）

この文書は「必要なら次は…」を無限に繰り返さないために、
**最初から最後までの流れ**を 0〜12 で固定化した "完全版" です。

目的はシンプルです。

- MCPツールが100個を超えても、会話が重くならない
- 必要なときだけ必要な情報を読み、必要な道具（MCP）だけを使う
- 自動化しつつ、危ない操作は必ず人が止められる
- すべての作業が GitHub Issue に記録され、再現できる

----

## まず覚える「5つのたとえ」
- **MCPツール**：便利な"道具"
- **Proxy**：受付（外から見えるのは受付だけ。中の道具は見えない）
- **Router**：道具選び係（どの道具を使うか判断する）
- **Skill**：手順書（毎回の作業を同じ形でやれるようにする）
- **Memory**：ノート（長文を会話に貼らず、必要部分だけ取り出す）

----

# 0. 絶対にブレてはいけないルール（ガバナンス）
## 0-1. "壊さない"が最優先
- 変更は小さく分割する
- いつでも元に戻せる粒度でPRを切る
- `npm test / npm run lint / npm run typecheck` を通すまでマージしない

## 0-2. 毎回 Issue を先に作る（ログの起点）
- 仕事の開始＝Issue作成
- 仕事の完了＝Issueに結果・リンク（PR/成果物/メモリ参照）を追記

## 0-3. 道具（MCP）は "見せない" が基本
- Claude側にMCPを増やすほど、会話が重くなる
- 原則：Claude側には **Proxy 1本だけ** つなぐ
- 内部のMCPはProxyの中で束ね、必要時に呼ぶ

## 0-4. 危ない操作は "人が最後に止められる"
- 例：deploy、課金、アカウント設定変更、削除、送信、公開
- こういう操作は **Human-in-the-loop（人間承認）** を必須にする

----

# 1. リポジトリ内の置き場（どこに何を置くか）
## 1-1. このリポジトリ（taisun_agent）で既に存在する場所
- `.claude/` : エージェント/スキル（Claude Code運用）
- `.mcp.json` : MCP接続設定（Claude Code側設定に近い役割）
- `docs/` : ドキュメント
- `config/` : 設定
- `src/` : 実装本体

## 1-2. 第三エージェントの"運用ルール"はここ
- `docs/third-agent/` に集約（この文書群）

----

# 2. Proxy（受付）でコンテキスト圧迫を止める
## 2-1. 何が起きるのか（イメージ）
- Claude Code は **Proxy 1つ** だけを "道具" として認識する
- Proxyの裏側に、GitHub/Notion/DB/Chrome など複数のMCPが並ぶ
- どのMCPを使うかは **Proxy内部** が判断する
- つまり：Claudeの会話に「道具の説明」を大量に詰め込まない

## 2-2. Proxyがやるべきこと（最低限）
- 入口（外向け）を少数に絞る（例：route / skill.run / memory.search）
- 内部MCPを束ねて、必要時だけ呼び出す
- 出力を整形し、長文はメモリに逃がす（会話に貼らない）

----

# 3. Routerを "ルール＋意味検索" のハイブリッドにする
ここが「世界トップクラス」に近づく重要ポイントです。

## 3-1. ルール（決め打ち）で守る部分
- 例：deploy系は必ず承認へ
- 例：削除/送信/公開は必ず確認へ
- 例：個人情報っぽいものは保存しない

→ ルールは **安全・高速・ブレない** のが強みです。

## 3-2. 意味検索（Semantic Router）で選ぶ部分
- "どの道具が一番合うか" を、文章の意味で近いものから選ぶ
- 道具の細かい定義を会話に持ち込まない
- 代わりに「道具カード（短い説明）」をベクトル検索で引く

→ 意味検索は **拡張に強い** のが強みです（道具が増えても運用が破綻しにくい）。

----

# 4. Memory（ノート）を "用途分離" する
Memoryは Mem0 でも Zep でもOKです。重要なのは **分け方** です。

## 4-1. 短期メモリ（すぐ捨ててもいい）
- 会話ログ、実行ログ、スクレイプした長文、解析結果の生データ
- 目的：必要になったら検索で引ける

## 4-2. 長期メモリ（残す価値がある）
- ユーザー方針、プロジェクト決定事項、重要な合意
- 目的：次回以降の判断が速くなる（ただし注入は最小）

## 4-3. 注入ルール（最重要）
- 会話に入れるのは **関連メモリの要点だけ**
- 全文は参照（検索）できるが、会話に貼り付けない
- Proxy側で「注入は最小・全文は参照」を規約化する

----

# 5. Chrome MCPでWebを"読む"→理解→スキル化へつなぐ
## 5-1. できるようになること（概念）
- WebページのDOM構造（画面の部品の並び）を理解できる
- 画面遷移（トップ→一覧→詳細→フォーム）を追える
- SPAでも「どの操作で何が起きたか」を観測できる
- その結果、サイトを"設計図（UIモデル）"として抽象化できる

## 5-2. 重要な注意（ガードレール）
- CAPTCHAを突破するような自動化はしない（人が対応）
- パスワード/決済/個人情報の入力は原則しない（必要なら承認）
- 規約違反になり得る操作（大量アクセス等）を避ける

----

# 6. Chrome拡張（リンク抽出）を組み込む
目的：URLを渡す → ページ内のリンクを集める → まとめて理解 → スキル化へ

- 既存拡張（Umbrella/Linkclump/Link Grabber）は参考になる
- ただし「確実に結果を取り出す」ために、最小の自作拡張も用意するのが安定

----

# 7. URL→スキル化は"テンプレ駆動"にする
## 7-1. なぜテンプレが必要？
- 何でもスキル化すると、無駄スキルが増えて運用が壊れる
- ドメイン別に「良いスキルの作り方」を固定すると精度が上がる

## 7-2. テンプレ例
- Docsサイト用（目次・章・APIリファレンス・FAQ）
- EC用（カテゴリ→商品→カート→決済）
- 社内ツール用（ログイン→一覧→編集→承認）

----

# 8. MCPの自動呼び出しは "skill.run の中" に閉じ込める
- Claude側に道具を増やさない
- スキルの中で、Proxyが内部MCPを呼ぶ
- 失敗しても影響範囲がスキルの中に閉じる（安全）

----

# 9. Supervisor（司令塔）で組織が増えても崩れない
- 組織A/B/C/Dが増えても、最後は司令塔が統括する
- "危ない操作" は必ず人間承認ノードへ流す
- タスク分解→並列→統合→レビュー→承認→デプロイ の流れを固定する

----

# 10. GitHub Issueログを標準化する（毎回ここに残す）
- 何をやったか
- なぜそうしたか
- どの道具/スキルを使ったか
- どこに成果物があるか（PR/ファイル/メモリ参照）
- 次に何をするか

----

# 11. "壊れない運用"のための品質ゲート
- 変更前後で `npm test` が通る
- `npm run lint` が通る
- `npm run typecheck` が通る
- 危ない操作は承認が取れている
- ログ（Issue）がある

----

# 12. 追加し続ける前提の手順（MCP/スキル）
- 新MCP追加は `10_CHECKLIST_ADD_MCP.md`
- 新スキル追加は `11_CHECKLIST_ADD_SKILL.md`
- 迷ったら「Claude側に露出させない」が基本方針
- まずProxy内に閉じる → どうしても必要な時だけ露出を検討

----

## このランブックのゴール
"道具が増えても、会話が重くならず、やり方が毎回同じで、危ない操作は止められて、ログが残る"
これが達成できれば、追加や拡張が怖くなくなります。
